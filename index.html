<!DOCTYPE html>
<html lang="en">

<head>
    <title>Vector Clock Prototype</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        to-do {
            width: 100%;
            display: block;
            position: relative;
            margin-top: 16px;
        }

        to-do button {
            margin-left: 8px;
        }

        body {
            margin: 0;
            padding: 32px;
        }
    </style>
</head>

<body>
    <button id="add">Add TODO</button>
    <div id="todos"></div>
    <script type="module">
        const add = document.getElementById('add');
        const todos = document.getElementById('todos');
        add.addEventListener('click', e => {
            const newTODO = new ToDoElement();
            todos.appendChild(newTODO);
        });

        const NODE_ID = localStorage.getItem('nodeId') || makeUUID();
        localStorage.setItem('nodeId', NODE_ID);

        let offlineQueue = [];

        let socket = new WebSocket('ws://localhost:8080');
        socket.addEventListener('open', e => {
            console.log('connected');
            while (offlineQueue.length > 0) {
                const {uid, clock, value, type} = offlineQueue.shift();
                dispatch(uid, clock, value, type);
            }
        });
        socket.addEventListener('message', e => {
            const data = JSON.parse(e.data);
            const el = todos.querySelector(`[uid="${data.uid}"]`);
            switch (data.type){
                case 'create':
                    const newTODO = new ToDoElement(data);
                    todos.appendChild(newTODO);    
                    break;
                case 'delete':
                    if (el) el.remove();
                    return;
                default:
                    if (el) el.update(data);
                    return;
            }
        });
        async function reconnect(){
            while (true){
                console.log('retrying in 10s');
                await new Promise(resolve => setTimeout(resolve, 10_000));
                if (socket.readyState === 1){
                    console.log('reconnected');
                    break;
                }
                socket = new WebSocket('ws://localhost:8080');
                await new Promise(resolve => setTimeout(resolve, 5_000));
                if (socket.readyState === 1){
                    console.log('reconnected');
                    break;
                }
            }
        }
        socket.addEventListener('close', e => {
            console.log('disconnected');
            reconnect();
        });

        function dispatch(uid, clock, value, type = 'update') {
            if (socket.readyState !== 1) {
                console.log('offline');
                offlineQueue.push({uid, clock, value, type});
                return;
            }
            socket.send(JSON.stringify({uid, clock, value, type}));
        }

        function makeUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        class ToDoElement extends HTMLElement {
            constructor(data = null) {
                super();
                if (data != null) {
                    this.uid = data.uid;
                    this.clock = new VectorClock(NODE_ID, data.clock);
                    this.value = data.value;
                } else {
                    this.uid = makeUUID();
                    this.clock = new VectorClock(NODE_ID);
                    this.value = "";
                    this.clock.increment();
                    dispatch(
                        this.uid,
                        this.clock.value(),
                        '',
                        'create',
                    );
                }
            }
            connectedCallback() {
                this.setAttribute('uid', this.uid);
                this.render();
            }
            update(data) {
                if (this.clock.merge(data.clock)) {
                    this.value = data.value;
                    this.render();
                }
            }
            render() {
                this.innerHTML = `
                        <input type="text" autocomplete="off" value="${this.value}" >
                        <button>del</button>
                    `;
                this.querySelector('input').addEventListener('change', e => {
                    this.clock.increment();
                    dispatch(
                        this.uid,
                        this.clock.value(),
                        e.target.value,
                    );
                });
                this.querySelector('button').addEventListener('click', e => {
                    dispatch(
                        this.uid,
                        this.clock.value(),
                        '',
                        'delete',
                    );
                    this.remove();
                });
            }
        }
        customElements.define('to-do', ToDoElement);

        class VectorClock {
            constructor(nodeId, clock = null) {
                this.step = 0;
                this.clock = {
                    nodes: [],
                    clock: [],
                };
                if (clock != null) {
                    this.clock = clock;
                }
                this.timestamp = Date.now();
                this.nodeId = nodeId;
                this.idx = this.clock.nodes.indexOf(this.nodeId);
                if (this.idx !== -1) {
                    this.step = this.clock.clock[this.idx][0];
                    this.timestamp = this.clock.clock[this.idx][1];
                }
                console.log(this.idx);
            }

            increment() {
                this.step++;
                this.timestamp = Date.now();
                if (this.idx === -1){
                    this.idx = this.clock.nodes.length;
                    this.clock.nodes[this.idx] = this.nodeId;
                }
                this.clock.clock[this.idx] = [this.step, this.timestamp];
                return this;
            }

            merge(clock) {
                const incoming = this.sum(clock);
                const current = this.sum(this.clock);
                console.log("merge", incoming, current, clock, {...this.clock});
                if (clock.nodes.length > this.clock.nodes.length) {
                    this.clock.nodes = clock.nodes;
                }
                if (incoming > current) {
                    for (let i = 0; i < clock.clock.length; i++){
                        this.clock.clock[i] = clock.clock[i];
                    }
                    this.idx = this.clock.nodes.indexOf(this.nodeId);
                    if (this.idx !== -1) this.step = this.clock.clock[this.idx][0];
                    return true;
                }
                else if (incoming === current){
                    console.log('conflict');
                    const incomingLastUpdate = this.lastUpdate(clock);
                    const lastUpdate = this.lastUpdate(this.clock);
                    if (incomingLastUpdate >= lastUpdate){
                        console.log('incoming wins');
                        for (let i = 0; i < clock.clock.length; i++){
                            this.clock.clock[i] = clock.clock[i];
                        }
                        this.idx = this.clock.nodes.indexOf(this.nodeId);
                        if (this.idx !== -1) this.step = this.clock.clock[this.idx][0];
                        return true;
                    }
                }
                return false;
            }

            value() {
                return {
                    ...this.clock,
                };
            }

            sum(clock) {
                let total = 0;
                for (const [step, timestamp] of clock.clock) {
                    total += step;
                }
                return total;
            }

            lastUpdate(clock){
                let last = 0;
                for (const [step, timestamp] of clock.clock) {
                    if (timestamp > last) last = timestamp;
                }
                return last;
            }
        }
    </script>
</body>

</html>
